# 解码方法

题目

```bash
一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2:

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

题解

本题难点在于需要考虑所有的情况比较复杂，我们利用动态规划解决这个问题，设置子状态为处于字符串中某一个位置之前的所有排序数，梳理清楚后，我们大概可以分成三种情况，首先是出现0的情况，如果出现0，那么意味着上一位必须是1或者2，那么这一位的值就需要和上上个dp的状态相同，然后是上一位为1或者2的情况，加上一定的限制条件，这一部分的dp可以表示为前两个dp状态的加和，剩下的一种状态就比较普通，直接和上一个dp状态相等即可，因为不可能出现其他的解码情况，后面给出了一种空间复杂度为O(1)的解法，不过还是上面的dp比较容易写出来一些，具体的代码如下。

```C++
// 动态规划
class Solution {
public:
    int numDecodings(string s) {
        if(s[0]=='0') return 0;
        int n = s.size();
        vector<int> dp(n+1, 1);
        for(int i=1; i<n; i++)
        {
            if(s[i]=='0')
            {
                if(s[i - 1] == '1' || s[i - 1] == '2') dp[i+1] = dp[i-1];
                else return 0;
            }
            else if(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6'))
                dp[i+1] = dp[i] + dp[i-1];
            else
                dp[i+1] = dp[i];
        }
        return dp[n];
    }
};

// 动态规划优化 O(1)空间改进
int numDecodings(string s) {
    if (s[0] == '0') return 0;
    int pre = 1, curr = 1;//dp[-1] = dp[0] = 1
    for (int i = 1; i < s.size(); i++) {
        int tmp = curr;
        if (s[i] == '0')
            if (s[i - 1] == '1' || s[i - 1] == '2') curr = pre;
            else return 0;
        else if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6'))
            curr = curr + pre;
        pre = tmp;
    }
    return curr;
}
```
