# 目标和

题目

```bash
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

 

示例：

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
 

提示：

数组非空，且长度不会超过 20 。
初始的数组的和不会超过 1000 。
保证返回的最终结果能被 32 位整数存下。
```

题解

此题目是一个动态规划问题，有一些类似背包问题，这里，我们定义dp[i][j]为前i个数字可以达到和j的一个状态，那么状态转移方程也比较好理解，就是当dp[i-1][j]有值的时候，dp[i][j+nums[i]] += dp[i-1][j]，
dp[i][j-nums[i]] += dp[i-1][j]，以此进行扩展，同时，注意到，初始的数组的和不会超过1000，因此，代码如下。中间有一个加1000的操作是为了避免数组中的j出现负值。

```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int n = nums.size();
        vector<int> temp(2001, 0);
        vector<vector<int>> dp(n, temp);
        dp[0][nums[0]+1000] = 1;
        dp[0][-1*nums[0]+1000] += 1;
        for(int i=1; i<n; i++)
        {
            for(int sum=-1000; sum<=1000; sum++)
            {
                if(dp[i-1][sum+1000] > 0)
                {
                    dp[i][sum+1000+nums[i]] += dp[i-1][sum+1000];
                    dp[i][sum+1000-nums[i]] += dp[i-1][sum+1000];
                }
            }
        }
        return S>1000?0:dp[n-1][S+1000];
    }
};
```
